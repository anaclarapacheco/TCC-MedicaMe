"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const strings_1 = require("@angular-devkit/core/src/utils/strings");
const core_1 = require("@angular-devkit/core");
const utils_1 = require("../utils");
const ts_utils_1 = require("../ts-utils");
const utils_2 = require("../generate/utils");
const module_info_utils_1 = require("./module-info-utils");
let nsext;
let moduleInfo;
function default_1(options) {
    return schematics_1.chain([
        (tree) => {
            const nsconfigExtensions = utils_2.getNsConfigExtension(tree);
            nsext = options.nsext || nsconfigExtensions.ns;
            if (!nsext.startsWith('.')) {
                nsext = '.' + nsext;
            }
        },
        (tree, context) => __awaiter(this, void 0, void 0, function* () {
            moduleInfo = yield module_info_utils_1.parseModuleInfo(options)(tree, context);
        }),
        (tree) => {
            const moduleDir = core_1.dirname(moduleInfo.modulePath);
            return addModuleFile(options.name, nsext, moduleDir)(tree);
        },
        (tree, context) => migrateComponents(moduleInfo, options)(tree, context),
        migrateProviders(),
        () => addCommonModuleFile(options, moduleInfo),
        schematics_1.schematic('convert-relative-imports', options),
    ]);
}
exports.default = default_1;
const addCommonModuleFile = (options, modInfo) => {
    const { name } = options;
    const { modulePath } = modInfo;
    const moduleDirectory = core_1.dirname(modulePath);
    const commonModuleOptions = {
        name,
        path: moduleDirectory,
    };
    return schematics_1.schematic('common-module', commonModuleOptions);
};
const addModuleFile = (name, nsExtension, path) => (_tree) => {
    const templateSource = schematics_1.apply(schematics_1.url('./_ns-files'), [
        schematics_1.template({
            name,
            nsext: nsExtension,
            dasherize: strings_1.dasherize,
            classify: strings_1.classify,
        }),
        schematics_1.move(path),
    ]);
    return schematics_1.mergeWith(templateSource);
};
const migrateComponents = (modInfo, options) => {
    const isComponent = (className) => className.endsWith('Component');
    const components = modInfo.declarations.filter(({ name }) => isComponent(name));
    return schematics_1.chain(components.map((component) => {
        const convertComponentOptions = {
            name: component.name,
            modulePath: modInfo.modulePath,
            nsext,
            project: options.project,
            style: options.style,
            skipConvertRelativeImports: true,
        };
        return schematics_1.schematic('migrate-component', convertComponentOptions);
    }));
};
const migrateProviders = () => (tree) => {
    moduleInfo.providers.forEach((provider) => {
        addProvider(provider.name, provider.importPath)(tree);
    });
};
const addProvider = (providerClassName, providerPath) => (tree) => {
    const nsModulePath = utils_1.addExtension(moduleInfo.modulePath, nsext);
    // check if the {N} version of the @NgModule exists
    if (!tree.exists(nsModulePath)) {
        throw new schematics_1.SchematicsException(`Module file [${nsModulePath}] doesn't exist.` +
            `Create it if you want the schematic to add ${moduleInfo.className} to its module providers,` +
            `or if you just want to update the component without updating its module, ` +
            `then rerun this command with --skip-module flag`);
    }
    // Get the changes required to update the @NgModule
    const changes = ast_utils_1.addProviderToModule(ts_utils_1.getSourceFile(tree, nsModulePath), 
    // nsModulePath, // <- this doesn't look like it is in use
    '', providerClassName, providerPath);
    // Save changes
    const recorder = tree.beginUpdate(nsModulePath);
    changes.forEach((change) => recorder.insertRight(change.pos, change.toAdd));
    tree.commitUpdate(recorder);
};
//# sourceMappingURL=index.js.map