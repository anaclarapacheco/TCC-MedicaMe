"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProjectObject = exports.getTsConfigFromProject = exports.getAngularProjectSettings = void 0;
const ts = require("typescript");
const path_1 = require("path");
const schematics_1 = require("@angular-devkit/schematics");
const ng_ast_utils_1 = require("@schematics/angular/utility/ng-ast-utils");
const workspace_1 = require("@schematics/angular/utility/workspace");
const utils_1 = require("./utils");
const ts_utils_1 = require("./ts-utils");
function getAngularProjectSettings(tree, projectName) {
    return __awaiter(this, void 0, void 0, function* () {
        const projectSettings = yield getCoreProjectSettings(tree, projectName);
        const tsResolver = getTypescriptResolver(tree, projectSettings.tsConfig);
        const entryModule = getEntryModuleMetadata(tree, projectSettings.mainPath, tsResolver);
        const entryComponent = getEntryComponentMetadata(tree, entryModule.path, tsResolver);
        const indexAppRootTag = getAppRootTag(tree, entryComponent.path);
        return Object.assign(Object.assign({}, projectSettings), { entryModuleClassName: entryModule.className, entryModuleImportPath: entryModule.importPath, entryModuleName: entryModule.name, entryModulePath: entryModule.path, entryComponentClassName: entryComponent.className, entryComponentImportPath: entryComponent.importPath, entryComponentName: entryComponent.name, entryComponentPath: entryComponent.path, indexAppRootTag,
            tsResolver });
    });
}
exports.getAngularProjectSettings = getAngularProjectSettings;
function getCoreProjectSettings(tree, projectName) {
    return __awaiter(this, void 0, void 0, function* () {
        const { targets, project } = yield parseAngularConfig(tree, projectName);
        if (!targets) {
            throw new schematics_1.SchematicsException(`Failed to find build targets for project ${projectName}!`);
        }
        const buildTarget = targets.get('build');
        if (!buildTarget) {
            throw new schematics_1.SchematicsException(`Failed to find build target for project ${projectName}!`);
        }
        const root = project.root;
        const sourceRoot = project.sourceRoot || 'src';
        const mainPath = utils_1.safeGet(buildTarget, 'options', 'main');
        const mainName = mainPath && path_1.basename(mainPath).replace(/\.ts$/, '');
        const prefix = project.prefix;
        const tsConfig = utils_1.safeGet(buildTarget, 'options', 'tsConfig');
        return {
            root,
            sourceRoot,
            mainName,
            mainPath,
            prefix,
            tsConfig,
        };
    });
}
function getTsConfigFromProject(tree, projectName) {
    return __awaiter(this, void 0, void 0, function* () {
        const { targets } = yield parseAngularConfig(tree, projectName);
        return utils_1.safeGet(targets, 'build', 'options', 'tsConfig');
    });
}
exports.getTsConfigFromProject = getTsConfigFromProject;
function parseAngularConfig(tree, projectName) {
    return __awaiter(this, void 0, void 0, function* () {
        const project = yield getProjectObject(tree, projectName);
        const targets = project.targets;
        return { targets, project };
    });
}
function getProjectObject(tree, projectName) {
    return __awaiter(this, void 0, void 0, function* () {
        const workspace = yield workspace_1.getWorkspace(tree);
        const project = workspace.projects.get(projectName);
        if (!project) {
            throw new schematics_1.SchematicsException(`Couldn't find project "${projectName}" in the workspace!`);
        }
        return project;
    });
}
exports.getProjectObject = getProjectObject;
function getEntryModuleMetadata(tree, mainPath, tsResolver) {
    const bootstrapCall = ng_ast_utils_1.findBootstrapModuleCall(tree, mainPath);
    if (!bootstrapCall) {
        throw new schematics_1.SchematicsException('Bootstrap call not found! Cannot build project data!');
    }
    const className = bootstrapCall.arguments[0].getText();
    const name = className.replace(/Module$/, '');
    const importPath = ng_ast_utils_1.findBootstrapModulePath(tree, mainPath);
    const path = tsResolver(importPath, mainPath);
    const metadata = {
        className,
        name,
        importPath,
        path,
    };
    return metadata;
}
// Step 3 - get appComponent and appComponentPath => open ${appRoot}/${entryModulePath}
// - get appComponent from bootstrap: [ __value__ ]
// - get appComponentPath from import { ${appComponent} } from '__value__'
function getEntryComponentMetadata(tree, entryModulePath, tsResolver) {
    const source = ts_utils_1.getSourceFile(tree, entryModulePath);
    // find -> bootstrap -> array -> array value
    // bootstrap: [
    //   AppComponent  <- end result
    // ],
    const node = ts_utils_1.findNode(source, [
        { kind: ts.SyntaxKind.PropertyAssignment, name: 'bootstrap' },
        { kind: ts.SyntaxKind.ArrayLiteralExpression },
    ]);
    const className = node.elements[0].getText();
    const name = className.replace('Component', '');
    const importPath = ts_utils_1.findImportPath(source, className);
    const path = tsResolver(importPath, entryModulePath);
    return {
        className,
        name,
        importPath,
        path,
    };
}
// Step 4 - get indexAppRootTag => open ${appRoot}/${appComponentPath} - get from selector: '__value__'
function getAppRootTag(tree, entryComponentPath) {
    const source = ts_utils_1.getSourceFile(tree, entryComponentPath);
    const node = ts_utils_1.findNode(source, [
        { kind: ts.SyntaxKind.PropertyAssignment, name: 'selector' },
        { kind: ts.SyntaxKind.StringLiteral },
    ]);
    const indexAppRootTag = node.text;
    return indexAppRootTag;
}
function getTypescriptResolver(tree, tsConfigName) {
    const parseConfigFileHost = createParseConfigFileHost(tree);
    const tsConfig = ts.getParsedCommandLineOfConfigFile(tsConfigName, ts.getDefaultCompilerOptions(), parseConfigFileHost);
    if (!tsConfig) {
        throw new schematics_1.SchematicsException(`Could not load tsconfig file: ${tsConfigName}`);
    }
    const compilerOptions = tsConfig.options;
    const moduleResolutionHost = {
        fileExists: parseConfigFileHost.fileExists,
        readFile: parseConfigFileHost.readFile,
    };
    return (moduleName, containingFilePath) => {
        const resolutionResult = ts.resolveModuleName(moduleName, containingFilePath, compilerOptions, moduleResolutionHost);
        if (resolutionResult.resolvedModule) {
            return resolutionResult.resolvedModule.resolvedFileName;
        }
        else {
            throw new schematics_1.SchematicsException(`Could not resolve ${moduleName} using config: ${tsConfigName}`);
        }
    };
}
function createParseConfigFileHost(tree) {
    const readFile = (filePath) => {
        const mainBuffer = tree.read(filePath);
        if (!mainBuffer) {
            throw new schematics_1.SchematicsException(`Main file (${filePath}) not found`);
        }
        return mainBuffer.toString('utf-8');
    };
    const fileExists = (filePath) => {
        return tree.exists(filePath);
    };
    // NOTE: readDirectory is called when there are include/exclude options in the tsconfig.
    // We don't need these for resolving so (hopefully) it's OK to just return []
    const readDirectory = (path, extensions, exclude, include, depth) => {
        return [];
    };
    const parseConfigFileHost = {
        getCurrentDirectory: () => '/',
        useCaseSensitiveFileNames: false,
        readDirectory,
        fileExists,
        readFile,
        onUnRecoverableConfigFileDiagnostic: () => Object,
    };
    return parseConfigFileHost;
}
//# sourceMappingURL=angular-project-parser.js.map