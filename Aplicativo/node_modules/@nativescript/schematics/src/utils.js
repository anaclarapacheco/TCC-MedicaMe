"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.moveToRoot = exports.safeGet = exports.findRelativeImportPath = exports.addExtension = exports.insertTextWhere = exports.toNgModuleClassName = exports.toComponentClassName = exports.stringUtils = exports.sanitize = exports.renameFilesForce = exports.renameFiles = exports.getFileContents = exports.getNsConfig = exports.getJsonFile = exports.overwritePackageJson = exports.getPackageJson = exports.addDependency = exports.copy = exports.removeNode = void 0;
const path_1 = require("path");
const schematics_1 = require("@angular-devkit/schematics");
const core_1 = require("@angular-devkit/core");
const stripJsonComments = require("strip-json-comments");
const PACKAGE_JSON = 'package.json';
class FileNotFoundException extends Error {
    constructor(fileName) {
        const message = `File ${fileName} not found!`;
        super(message);
    }
}
const removeNode = (node, filePath, tree) => {
    const recorder = tree.beginUpdate(filePath);
    const start = node.getFullStart();
    const end = node.getEnd();
    recorder.remove(start, end - start);
    tree.commitUpdate(recorder);
};
exports.removeNode = removeNode;
const copy = (tree, from, to) => {
    const file = tree.get(from);
    if (!file) {
        throw new Error(`File ${from} does not exist!`);
    }
    tree.create(to, file.content);
};
exports.copy = copy;
const addDependency = (tree, dependency, packageJsonDir) => {
    const path = packageJsonDir ?
        `${packageJsonDir}/package.json` :
        'package.json';
    const packageJson = exports.getJsonFile(tree, path);
    if (dependency.type === 'dependency') {
        const dependenciesMap = Object.assign({}, packageJson.dependecies);
        packageJson.dependecies = setDependency(dependenciesMap, dependency);
    }
    else {
        const dependenciesMap = Object.assign({}, packageJson.devDependencies);
        packageJson.devDependencies = setDependency(dependenciesMap, dependency);
    }
    tree.overwrite(path, JSON.stringify(packageJson, null, 2));
};
exports.addDependency = addDependency;
const setDependency = (dependenciesMap, { name, version }) => (Object.assign(Object.assign({}, dependenciesMap), { [name]: version }));
const getPackageJson = (tree, workingDirectory = '') => {
    const url = path_1.join(workingDirectory, PACKAGE_JSON);
    return exports.getJsonFile(tree, url);
};
exports.getPackageJson = getPackageJson;
const overwritePackageJson = (tree, content, workingDirectory = '') => {
    const url = path_1.join(workingDirectory, PACKAGE_JSON);
    tree.overwrite(url, JSON.stringify(content, null, 2));
};
exports.overwritePackageJson = overwritePackageJson;
const getJsonFile = (tree, path) => {
    const file = tree.get(path);
    if (!file) {
        throw new FileNotFoundException(path);
    }
    try {
        const content = JSON.parse(stripJsonComments(file.content.toString()));
        return content;
    }
    catch (e) {
        throw new schematics_1.SchematicsException(`File ${path} could not be parsed!`);
    }
};
exports.getJsonFile = getJsonFile;
const getNsConfig = (tree) => {
    return exports.getJsonFile(tree, '/nsconfig.json');
};
exports.getNsConfig = getNsConfig;
const getFileContents = (tree, filePath) => {
    const buffer = tree.read(filePath) || '';
    return buffer.toString();
};
exports.getFileContents = getFileContents;
const renameFiles = (paths) => (tree) => paths.forEach(({ from, to }) => tree.rename(from, to));
exports.renameFiles = renameFiles;
const renameFilesForce = (paths) => (tree) => paths.forEach(({ from, to }) => {
    const content = exports.getFileContents(tree, from);
    tree.create(to, content);
    tree.delete(from);
});
exports.renameFilesForce = renameFilesForce;
/**
 * Sanitizes a given string by removing all characters that
 * are not letters or digits.
 *
 * ```javascript
 * sanitize('nativescript-app');  // 'nativescriptapp'
 * sanitize('action_name');       // 'actioname'
 * sanitize('css-class-name');    // 'cssclassname'
 * sanitize('my favorite items'); // 'myfavoriteitems'
 * ```
 * @method sanitize
 * @param {String} str The string to sanitize.
 * @return {String} the sanitized string.
 */
const sanitize = (str) => str
    .split('')
    .filter((char) => /[a-zA-Z0-9]/.test(char))
    .join('');
exports.sanitize = sanitize;
exports.stringUtils = Object.assign(Object.assign({}, core_1.strings), { sanitize: exports.sanitize });
const toComponentClassName = (name) => `${exports.stringUtils.classify(name)}Component`;
exports.toComponentClassName = toComponentClassName;
const toNgModuleClassName = (name) => `${exports.stringUtils.classify(name)}Module`;
exports.toNgModuleClassName = toNgModuleClassName;
/**
 * Example: source: abc.123.def , text: -x-, where: .123 => abc-x-.123.def
 */
const insertTextWhere = (source, text, where) => {
    const index = source.indexOf(where);
    return source.substring(0, index) + text + source.substring(index);
};
exports.insertTextWhere = insertTextWhere;
const addExtension = (path, extension) => {
    const index = path.lastIndexOf('.');
    const newPath = path.slice(0, index) + extension + path.slice(index);
    return newPath;
};
exports.addExtension = addExtension;
/**
 * Find relative path, and remove .tns (to make it an import path)
 * @param from path to the importing file
 * @param to path to the imported file
 */
const findRelativeImportPath = (from, to) => {
    // Make sure that if one of the paths starts with '/', the other one does too
    const toStartsWithSlash = to.startsWith('/');
    const fromStartsWithSlash = from.startsWith('/');
    if (toStartsWithSlash && !fromStartsWithSlash) {
        from = '/' + from;
    }
    else if (!toStartsWithSlash && fromStartsWithSlash) {
        to = '/' + to;
    }
    let relativePath = path_1.relative(from, to);
    // if starts with ../../ then relative is going to skip one folder too many
    if (relativePath.startsWith('../../')) {
        relativePath = relativePath.replace('../../', '../');
    }
    else if (relativePath.startsWith('../')) {
        relativePath = relativePath.replace('../', './');
    }
    else if (relativePath === '') {
        relativePath = './';
    }
    return relativePath.replace(/.ts$/, '');
};
exports.findRelativeImportPath = findRelativeImportPath;
function safeGet(object, ...properties) {
    if (properties.length === 0) {
        return object;
    }
    if (!object) {
        return;
    }
    const firstProperty = properties.shift();
    const value = object[firstProperty];
    if (!value) {
        return;
    }
    return safeGet(value, ...properties);
}
exports.safeGet = safeGet;
/**
 * Move the sources of a tree from a specified directory to the root.
 * Example: move the application of a project to root level,
 * so we can call schematics that depend on being executed inside a project.
 */
const moveToRoot = (schematicRunner, tree, from) => callRuleSync(schematicRunner, () => schematics_1.move(from, '.'), tree);
exports.moveToRoot = moveToRoot;
function callRuleSync(schematicRunner, rule, tree) {
    let newTree;
    schematicRunner.callRule(rule, tree)
        .subscribe((t) => newTree = t);
    if (newTree === undefined) {
        throw new schematics_1.SchematicsException('The provided rule is async! Use with `callRule` instead!');
    }
    return newTree;
}
//# sourceMappingURL=utils.js.map